#' Convert Synthetic Uniform Data Back to Original Domain
#'
#' This function transforms synthetic data from the uniform [0,1] space back to
#' the original data domain using inverse ECDF for categorical variables and quantiles
#' for continuous variables.
#'
#' @param synthetic_uniform A data frame where each column represents a synthetic variable
#'                          sampled from a uniform distribution in [0,1].
#' @param data_model  A data model generated by create_model
#' @return A data frame with synthetic data transformed back to its original scale.
#' @examples
#' synthetic_uniform <- data.frame(A = runif(1000), B = runif(1000))
#' data_type=list(A='numeric',B='numeric')
#' df_model <- create_model(df, data_type)
#' converted_data <- convert_back_original(df_model,synthetic_uniform)
#' @keywords internal
convert_back_original <- function(data_model,synthetic_uniform) {

  # Convert synthetic data back to the original scale
  synthetic_data <- as.data.frame(setNames(lapply(data_model$metadata$col_names, function(col_name) {

    # Get the column type from df_struct
    col_type <- data_model$metadata[col_name, 'col_type']
    if (col_type =='text')
    {
      ret<-paste0('Text:',seq(1:NROW(synthetic_uniform)))
    }else if (col_type =='key')
    {
      ret<-seq(1:NROW(synthetic_uniform))

    }else if (col_type == 'factor') {
      # For categorical variables, use the inverse ECDF function to map probabilities back to categories
      message(paste0(col_name,":","Using ECDF category inverse transformation"))
      fun <- attr(data_model$transformed[[col_name]]$fun, 'inverse')
      ret <- factor(fun(synthetic_uniform[, col_name]),levels=levels(data_model$data_converted[,col_name]))

    } else {

      method<-data_model$transformed[[col_name]]$method
      # For continuous/numeric variables
      if (method == "ecdf") {
        message(paste0(col_name,":","Using ECDF inverse transformation"))
        #use quantile function for inverse transformation
        ret <- quantile( data_model$data_converted[, col_name], synthetic_uniform[, col_name])

      }else if (method == "beta") {
        message(paste0(col_name,":","Using Beta inverse transformation"))
        params<-data_model$transformed[[col_name]]$params
        x_scaled <-qbeta( synthetic_uniform[, col_name],params$shape1, params$shape2)
        ret<-params$min_x + x_scaled*(params$max_x - params$min_x)

      }else if (method == "normal") {
        message(paste0(col_name,":","Using Normal inverse transformation"))
        params<-data_model$transformed[[col_name]]$params
        ret<-qnorm(synthetic_uniform[, col_name], params$mean, params$sd)

      }else if (method == "gamma") {
        message(paste0(col_name,":","Using Gamma inverse transformation"))
        params<-data_model$transformed[[col_name]]$params
        x_shifted <- qgamma(synthetic_uniform[, col_name], params$shape, params$rate)
        ret<- x_shifted - params$shift
      } else {
        stop(paste0(col_name,":","Unknown transformation method"))
      }



    }

    # If column type is integer, round to the nearest integer
    if (col_type == 'integer') {
      ret <- round(ret, 0)
    }

    # If column type is datetime, convert from numeric (POSIXct format)
    if (col_type %in% c('date','datetime')) {
      ret <- as.POSIXct(ret, origin = "1970-01-01")
    }

    # Return the transformed column
    ret
  }),data_model$metadata$col_names))

  # Return the final converted synthetic data frame
  return(synthetic_data)
}
